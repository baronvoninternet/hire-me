import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';
import { fetchCount, fetchChildren, checkInChildAPI, checkOutChildAPI } from './childListAPI';

export type ChildId = string;

export type ChildName = {
  fullName: string,
  firstName?: string,
  middleName?: string,
  lastName?: string
}

export type Child = {
  // TODO: This only includes what we're interested in right now, but we should add proper definition from API docs
  [key: string]: unknown;
  name: ChildName;
  checkedIn: boolean;
  childId: ChildId;
  groupId?: string;
  institutionId?: string;
}

export type PagedData<T> = {
  data: T[],
  page?: number,
  perPage?: number,
  hasMore?: boolean,
}

export type PagedDataRequest = {
  page: number,
  perPage: number
}

export interface ChildListState {
  children: PagedData<Child>;
}

const initialState: ChildListState = {
  children: {
    data: [],
  },
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const checkInChildAsync = createAsyncThunk(
  'childlist/checkInChildAsync',
  async (childId: ChildId) => {
    const response = await checkInChildAPI(childId);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const checkOutChildAsync = createAsyncThunk(
  'childlist/checkOutChildAsync',
  async (childId: ChildId) => {
    const response = await checkOutChildAPI(childId);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const loadChildrenDataAsync = createAsyncThunk(
  'childList/loadChildrenDataAsync',
  async (pagingRequest: PagedDataRequest) => {
    const response = await fetchChildren(pagingRequest.page, pagingRequest.perPage);
    return response;
  }
);

export const childListSlice = createSlice({
  name: 'childList',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setCurrentChildren: (state, action: PayloadAction<PagedData<Child>>) => {
      state.children.data = action.payload.data;
    },
    checkInChild: (state, action: PayloadAction<ChildId>) => {
      const childIndex = state.children.data.findIndex((child: Child) => child.childId === action.payload);
      state.children.data[childIndex].checkedIn = true;
    },
    checkOutChild: (state, action: PayloadAction<ChildId>) => {
      const childIndex = state.children.data.findIndex((child: Child) => child.childId === action.payload);
      state.children.data[childIndex].checkedIn = false;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(checkInChildAsync.pending, (state, action) => {
        // TODO: add some sort of blocking for repeated clicks until fulfilled
      })
      .addCase(checkInChildAsync.fulfilled, (state, action) => {
        if (action.payload.success === true) {
          const childIndex = state.children.data.findIndex((child: Child) => child.childId === action.payload.childId);
          state.children.data[childIndex].checkedIn = true;
        }
      })
      .addCase(checkOutChildAsync.pending, (state, action) => {
        // TODO: add some sort of blocking for repeated clicks until fulfilled
      })
      .addCase(checkOutChildAsync.fulfilled, (state, action) => {
        if (action.payload.success === true) {
          const childIndex = state.children.data.findIndex((child: Child) => child.childId === action.payload.childId);
          state.children.data[childIndex].checkedIn = false;
        }
      })
      .addCase(loadChildrenDataAsync.pending, (state, action) => {
        // TODO: add some sort of blocking for repeated clicks until fulfilled
      })
      .addCase(loadChildrenDataAsync.fulfilled, (state, action) => {
        state.children = action.payload;
      })
  },
});

export const {
  setCurrentChildren,
  checkInChild,
  checkOutChild,
} = childListSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.childList.value)`
export const selectChildren = (state: RootState) => state.childList.children;


export default childListSlice.reducer;
